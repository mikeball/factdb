Poor manâ€™s datomic. Target use case: smallish business apps.
* focus is on fact storage and retrieval. Summarization is outside of scope.


So Datomic is just so very heavy weight, it's total overkill for small apps,
and especially for microservices. It's almost the antithesis of microservices.
But the logical model is just so much more correct than anything else. How to resolve this?
  What if we had "micro-peers" that where micro-peer stored only the data related
to a single unit of code. For instance take a list of products, could there not be
a micro-peer for just the list of products that was sort of similar to the full datomic
peer, but it uses a snapshot of a point in time + changes afterwards. So would a product detail
function from a micro-peer that cached all products details?





In general how to handle schema migrations?
Especially how to handle schema data type change?
  From string to int?
  What should happen in query that returns a property that has facts both before and after a type change?
  * need to learn from Rich's thoughts on clojure.spec name changes especially cognitect podcast on it.

Could/should we push out a change notification via pg-notify?

https://news.ycombinator.com/item?id=10316872&utm_source=postgresweekly&utm_medium=email



What if a column schema allowed a list of allowed types for a given property?
  for instance a property storing a rate could be positive rate or negative rate type
  might also allow to say we know a person has a middle name but it's currently unknown
  or might be able to say middle name could be name(text), has-no-name or unknown.
    for unknown you might ask to complete complete middle name data
    or might be able to say it's a US name or a complex name type from other country.

### Application Usage Models ###

#1 - perform a query with results as of current point in time,
then be notified of changes to said query.

-- so this is initial query+result+changes called a query feed? query plug?
-- clients can plug into the query plug.

where product/category = 11
    select product/name
           category/name


-- we have issues with the push... we need to know the id of the sub entity id's
-- in order to merge the data remotely.
-- so how about by default the id is always included in results for each property namespace.

-- so for this initial query feed

[{product/id: 1  product/name:"product a" category/id: 3 category/name: "category a"}
 {product/id: 2  product/name:"product b" category/id: 3 category/name: "category a"}]

-- so now if the category id 3 has it's category/name updated a change-set is triggered
[where-properties new-values]
[{category/id: 3} {category/name "category aa"}]

-- which is then merged into the updated result-set
[{product/id: 1  product/name:"product a" category/id: 3 category/name: "category aa"}}
 {product/id: 2  product/name:"product b" category/id: 3 category/name: "category aa"}]






# Name ###
postfact
factomatic
fatomic
mea - hawaiian for fact



### numbering/identity ###
Using a single sequence so that every table PK is
a time sequenced gives us the ability to query the state of something,
then also get all facts/retractions that have occured
after that initial point in time state.

done.





### datatypes ###

So, if the query engine knows the type of an attribute, it can query the correct column or table.

#1 Sparse columns might not have issues with concurrency that come up with table inheritance?

#2 suppose we could also union the different tables into a sparse column result set...

#3 Table Inheritance with different queries.. Seems most attractive.

facts (fid,tid,eid,pid)
facts_int (value)
facts_text (value)
facts_datetime (value)


-- Pretty sure we would need to send multiple queries for each prop type to db,
-- then combine the results in the driver. Also don't forget result reading
-- is dependent on ordering of items.
-- also don't forget that we need to view the different queries as-of a single point in time


-- http://stackoverflow.com/questions/8909069/storing-varying-data-types-in-a-postgresql-database





### Relationships ###

# belongs too... for example product belongs to a category

so category has entity id 11, attribute category/name which is a string
    product/category is a property
        that's an integer?
        that's an entity/id  (this is datomic's choice)
        that's an entity/id where it's a also a category?


let's create a new product in that category

on new assert
  product/category = 11
  product/name = `harness`

# let's select a list of products in that category
where product/category = 11
    select entity/id,
           product/name


# what about a list containing both category and product information?
# should this even be allowed?
where product/category
    select entity/id,       (* products entity/id)
           product/name
           category/name

# could this be accomplished at app level...
#   - pull & cache categories facts desired
#   - pull products list
# name of the category is pulled from cache.


********************************
# so from this query
where product/category = 3
    select product/name category/name

# so we need this
[{product/id: 1  product/name:"product a" category/id: 3 category/name: "category a"}
 {product/id: 2  product/name:"product b" category/id: 3 category/name: "category a"}]

# how to do this given product/category = 3
- join back onto entities->properties?

create table properties ( -- should this be called attributes?
    pid bigint DEFAULT nextval('serial') primary key not null,
    type text not null,
    name text not null );

create table entities (
    eid bigint DEFAULT nextval('serial') primary key not null,
    meta text not null );

create table current_facts (
    cfid bigint DEFAULT nextval('serial') primary key not null,
    eid bigint not null references entities,
    pid bigint not null references properties );

create table current_facts_text ( value text not null ) inherits (current_facts);

- get the property id and datatype for the product/category property
- get list of entity id's that have a property with the product/category value
- get all properties for the list of entities

$pid = 44
select *
  from current_facts_int cfi
  where cfi.pid = product/category
    and cfi.value = 3


to be continued... the rabbit hole is deep, this one is.
***************************************










# for many to many, create a relationship entity
on new assert
    product-category/category = 11
    product-category/product = 22


# to query list of products in a category then? ohy vey.
# how about some sort of join? implicitly on entity id ?

where product-category/category = 11
    join product-category/product
    select product-category/product
           entity/id                   (* the products entity id!)
           product/name



One to One? (eg biological mother?)





### Schema Migrations ###

How the heck to handle schema rule changes?
  simple addition of row to the properties table?

What about when an attribute goes from optional to required?
  does required have any meaning if we don't have "entity" type rules?

How to remove a property from database?
  mark property as removed?
  I guess assert needs to look up property on assert?
  can you retract a fact on a removed property?
  what if you re-add the same property name at later point in time?

https://news.ycombinator.com/item?id=10145933





### Syntax ###

where entity/id = 111
	select1 person/name, shirt/color

where shirt/color = `blue`
	select entity/id, person/name


where shirt/color = `blue`
	select entity/id, person/name


select shirt/color, (count entity/id)


# How would we assert facts?

on id=101 assert
	person/name = `bob`,
	shirt/color = `blue`


# assert a new user and roles
on new assert
	user/name = `bob`,
	user/roles = [11 22]



# upsert syntax?
# Is upsert even necessary because at the core if you state a fact that is
# the same as it presently is, shouldn't it just be ignored?
# probably need a re-assert statement
on id=101 else new assert
    user/name = `bob`





# How to retract a fact?
on id = 101 retract
	person/name, shirt/color




# How to forget a fact? Perhaps delete is better term? Excision?
on id = 101 excise
  person/name

  on id = 101 forget
    person/name





# Should entities have type?
 Tables serve this function in sql. should there be rules around what compromises an entity?
 Datomic has no concept of entity type rules, just collection of attributes with rules about each attribute.

related
    http://kevinmahoney.co.uk/articles/log-orientated-data/
    http://docs.datomic.com/best-practices.html



# How to assert negatives / unknowns?





# Implementation Ideas
* Given the need for the client to see almost all data grouped by entity, might it make sense to use a sparse fill factor and cluster on entity id? This would be rather than clustering on a sequnce id as primary key.

* Look into use of BRIN indexes for keys,
    not as fast as BTREE but dramatically less space usage for large amounts of data
