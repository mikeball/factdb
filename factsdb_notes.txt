Poor manâ€™s datomic. Target use case: smallish business apps.
* focus is on fact storage and retrieval. Summarization is outside of scope.




In general how to handle schema migrations?
Especially how to handle schema data type change?
  From string to int?


Could/should we push out a change notification via pg-notify?

https://news.ycombinator.com/item?id=10316872&utm_source=postgresweekly&utm_medium=email


# Name ###
postfact
factomatic
datom-pg



### numbering/identity ###
Using a single sequence so that every table PK is
a time sequenced gives us the ability to query the state of something,
then also get all facts/retractions that have occured
after that initial point in time state.

done.





### datatypes ###

So, if the query engine knows the type of an attribute, it can query the correct column or table.

#1 Sparse columns might not have issues with concurrency that come up with table inheritance?

#2 suppose we could also union the different tables into a sparse column result set...

#3 Table Inheritance with different queries.. Seems more attractive?

facts (fid,tid,eid,pid)
facts_int (value)
facts_text (value)
facts_datetime (value)


Pretty sure we would need to send multiple queries for each prop type to db, then combine the results in the driver. Also don't forget result reading is highly dependant on ordering of items.


# http://stackoverflow.com/questions/8909069/storing-varying-data-types-in-a-postgresql-database





### Relationships ###

# belongs too... for example product belongs to a category

so category has entity id 11, attribute category/name which is a string
    product/category is a property
        that's an integer?
        that's an entity/id  (this is datomic's choice)
        that's an entity/id where it's a also a category?


let's create a new product in that category

on new assert
  product/category = 11
  product/name = `harness`

# let's select a list of products in that category
where product/category = 11
    select entity/id,
           product/name


# what about a list containing both category and product information?
# should this even be allowed?
where product/category
    select category/name
           entity/id,       (* products entity/id)
           product/name

# could this be accomplished at app level...
#   - pull & cache categories facts desired
#   - pull products list
# name of the category is pulled from cache.








# for many to many, create a relationship entity
on new assert
    product-category/category = 11
    product-category/product = 22


# to query list of products in a category then? ohy vey.
# how about some sort of join? implicitly on entity id ?

where product-category/category = 11
    join product-category/product
    select product-category/product
           entity/id                   (* the products entity id!)
           product/name



One to One? (eg biological mother?)





### Schema Migrations ###

How the heck to handle schema rule changes?
  simple addition of row to the properties table?

What about when an attribute goes from optional to required?
  does required have any meaning if we don't have "entity" type rules?

How to remove a property from database?
  mark property as removed?
  I guess assert needs to look up property on assert?
  can you retract a fact on a removed property?
  what if you re-add the same property name at later point in time?

https://news.ycombinator.com/item?id=10145933





### Syntax ###

where entity/id = 111
	select1 person/name, shirt/color

where shirt/color = `blue`
	select entity/id, person/name


where shirt/color = `blue`
	select entity/id, person/name


select shirt/color, (count entity/id)


# How would we assert facts?

on id=101 assert
	person/name = `bob`,
	shirt/color = `blue`


# assert a new user and roles
on new assert
	user/name = `bob`,
	user/roles = [11 22]



# upsert syntax?
# Is upsert even necessary because at the core if you state a fact that is
# the same as it presently is, shouldn't it just be ignored?
on id=101 else new assert
    user/name = `bob`





# How to retract a fact?
on id = 101 retract
	person/name, shirt/color




# How to forget a fact? Perhaps delete is better term? Excision?
on id = 101 excise
  person/name






# Should entities have type?
 Tables serve this function in sql. should there be rules around what compromises an entity?
 Datomic has no concept of entity type rules, just collection of attributes with rules about each attribute.

related
    http://kevinmahoney.co.uk/articles/log-orientated-data/
    http://docs.datomic.com/best-practices.html



# How to assert negatives / unknowns?





# Implementation Ideas
* Given the need for the client to see almost all data grouped by entity, might it make sense to use a sparse fill factor and cluster on entity id? This would be rather than clustering on a sequnce id as primary key.

* Look into use of BRIN indexes for keys,
    not as fast as BTREE but dramatically less space usage for large amounts of data
